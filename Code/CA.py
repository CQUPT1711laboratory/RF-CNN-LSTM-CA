import numpy as np
import copy
import time
import random
import math

startTime = time.time()

# Land use / cover Ascii data, derived from ArcGIS.
base_landuse = np.loadtxt('...', skiprows=6)
column = base_landuse.shape[1]
row1 = base_landuse.shape[0]

needs1 = [7071, 931, 12822, 1154, 87536, 2100]  # land use change of 2010 to 2020
count_class = [2410124, 12936, 1198496, 30064, 127763, 60015]  # land use number of base_landuse
count_classn = np.array(count_class)
needs = [2316528, 13867, 1200782, 31218, 215299, 61704]  # land use number of end_landuse

needsn = np.array(needs)
con_landuseclasses = [2, 4, 5, -9999]
index_start = [0, 0, 0, 0, 0, 0]
visit = np.zeros(shape=base_landuse.shape)


def integrationAll():
    list = []
    # Probability data of different land use changes generated by random forests.
    probaAll = np.loadtxt('...')
    MIndexs = np.array(list)
    list1 = []
    probas = np.array(list1)
    max_proba = copy.deepcopy(probaAll)
    for j in range(1, probaAll.shape[1]):
        max_index = max_proba[:, j]
        max_index = max_index.argsort()[::-1]
        if MIndexs.shape[0] == 0:
            MIndexs = max_index
            probas = probaAll[:, j]
        else:
            MIndexs = np.vstack((MIndexs, max_index))
            probas = np.vstack((probas, probaAll[:, j]))
    print(MIndexs.shape)
    print(probas.shape)
    return MIndexs, probas


MIndexs, probas = integrationAll()

# Transaction Matrix of 2015~2020 land use/cover
transM = [[0.982572, 0.000162, 0.003934, 0.000259, 0.012711, 0.000362],
          [0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 0.000000],
          [0.003550, 0.000159, 0.995349, 0.000152, 0.000717, 0.000074],
          [0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000],
          [0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000],
          [0.002098, 0.000393, 0.000705, 0.000000, 0.001049, 0.995756]]


def prepared():
    for j in range(6):
        num = 0
        if (count_class[j] > needs[j]):
            need = needs1[j]
            proba = probas[j]
            # proba.reshape(row1, column)
            MIndex = MIndexs[j]
            s1 = np.floor(MIndex / column)
            s1 = s1.astype(int)
            s2 = MIndex % column
            MIndex = np.vstack((s1, s2))
            MIndex = MIndex.transpose()  # 行转列
            print("----------------prepared-landuse:", j + 1, "----------------------")
            for i in MIndex:
                if num >= need:
                    break
                index_start[j] += 1
                row = i[0]
                col = i[1]
                if row < 1 or col < 1 or row > 2382 or col > 2908:
                    continue
                if np.all(base_landuse[row - 1:row + 2, col - 1:col + 2] != -9999) and \
                        base_landuse[row][col] != (j + 1):
                    sMin = base_landuse[row - 1:row + 2, col - 1:col + 2]
                    list = [len(sMin[sMin == (j + 1)]) for j in [0, 1, 2, 3, 4, 5]]
                    r = random.uniform(0, 1)
                    R = 1 + math.pow(-math.log(r, math.e), 5)
                    tp = (proba[row * column + col]) * R
                    count_class[int(base_landuse[row, col]) - 1] -= 1
                    base_landuse[row, col] = j + 1
                    visit[row, col] = tp
                    count_class[j] += 1
                    num += 1
            print(num)


# CA based on HQSSIA
def ca():
    prepared()
    while (count_class != needs):
        for j in range(6):
            if (count_class[j] >= needs[j]):
                continue
            else:
                proba = probas[j]
                MIndex = MIndexs[j]
                s1 = np.floor(MIndex / column)
                s1 = s1.astype(int)
                s2 = MIndex % column
                MIndex = np.vstack((s1, s2))
                MIndex = MIndex.transpose()
                print("-----------------landuse:", j + 1, "----------------------")
                for i in MIndex[index_start[j]:]:
                    if count_class[j] >= needs[j]:
                        break
                    row = i[0]
                    col = i[1]
                    index_start[j] += 1
                    if row < 1 or col < 1 or row > 2382 or col > 2908:
                        continue
                    if base_landuse[row, col] != -9999 and \
                            base_landuse[row][col] != (j + 1):
                        r = random.uniform(0, 1)
                        R = 1 + math.pow(-math.log(r, math.e), 5)
                        tp = proba[row * column + col] * R
                        if tp > visit[row, col]:
                            visit[row, col] = tp
                            count_class[int(base_landuse[row, col]) - 1] -= 1
                            base_landuse[row, col] = j + 1
                            count_class[j] += 1
            print("count:", count_class)
            print("index:", index_start)
            print()
    return base_landuse


def prepared_random(probaAll):
    for j in range(6):
        if (count_class[j] > needs[j]):
            probas = probaAll[:, j + 1]
            print(probas.shape)
            avg = np.mean(probas[:6923420])
            print("avg", avg)
            num = 0
            need = needs1[j]
            while num < need:
                row = np.random.choice(range(1, base_landuse.shape[0]))
                col = np.random.choice(range(1, base_landuse.shape[1]))
                proba = probas[row * column + col]
                if base_landuse[row, col] == -9999 or row < 1 or col < 1 or row > 2382 or col > 2908 or \
                        transM[int(base_landuse[row, col]) - 1][j] == 0 or proba < np.random.uniform() * avg:
                    continue
                if base_landuse[row][col] != (j + 1):
                    r = random.uniform(0, 1)
                    R = 1 + math.pow(-math.log(r, math.e), 5)
                    tp = (proba) * R
                    count_class[int(base_landuse[row, col]) - 1] -= 1
                    base_landuse[row, col] = j + 1
                    visit[row, col] = tp
                    count_class[j] += 1
                    num += 1
            print(num)


# CA based on a random seed selection algorithm
def ca_random():
    probaAll = np.loadtxt('../cq21/1020/sample/rf2010All_cnnlstm_w3.txt')
    prepared_random(probaAll)
    while (count_class != needs):
        for j in range(6):
            probas = probaAll[:, j + 1]
            avg = np.mean(probas[:6923420])
            print("-----------------landuse:", j + 1, "----------------------")
            while count_class[j] < needs[j]:
                row = np.random.choice(range(1, base_landuse.shape[0]))
                col = np.random.choice(range(1, base_landuse.shape[1]))
                proba = probas[row * column + col]
                if base_landuse[row, col] == -9999 or row < 1 or col < 1 or row > 2382 or col > 2908 or \
                        transM[int(base_landuse[row, col]) - 1][j] == 0 or proba < np.random.uniform() * avg * 10:
                    continue
                if base_landuse[row, col] != -9999 and base_landuse[row][col] != (j + 1):
                    tp = (proba)
                    r = random.uniform(0, 1)
                    R = 1 + math.pow(-math.log(r, math.e), 5)
                    if tp * R > visit[row, col]:
                        visit[row, col] = proba
                        count_class[int(base_landuse[row, col]) - 1] -= 1
                        base_landuse[row, col] = j + 1
                        count_class[j] += 1
            print("count:", count_class)
            print()

    return base_landuse


urban = ca()
# urban = ca_random()


print("-------------   distribute finish!!!    -------------------")
np.savetxt("../cq21/2025/result/temp1.txt", urban, fmt='%f',
           header='ncols         2909\nnrows         2383\nxllcorner     105.28966287628\nyllcorner     28.454112453727\ncellsize      0.00083333333\nNODATA_value  -9999',
           comments='')

endTime = time.time()
print(endTime - startTime)
